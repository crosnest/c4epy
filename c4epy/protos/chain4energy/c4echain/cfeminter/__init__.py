# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: c4echain/cfeminter/event.proto, c4echain/cfeminter/genesis.proto, c4echain/cfeminter/minter.proto, c4echain/cfeminter/params.proto, c4echain/cfeminter/query.proto, c4echain/cfeminter/tx.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import (
    datetime,
    timedelta,
)
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class Mint(betterproto.Message):
    bonded_ratio: str = betterproto.string_field(1)
    inflation: str = betterproto.string_field(2)
    amount: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class Minter(betterproto.Message):
    sequence_id: int = betterproto.uint32_field(1)
    end_time: datetime = betterproto.message_field(2)
    config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class NoMinting(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class LinearMinting(betterproto.Message):
    amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ExponentialStepMinting(betterproto.Message):
    step_duration: timedelta = betterproto.message_field(1)
    amount: str = betterproto.string_field(2)
    amount_multiplier: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class MinterState(betterproto.Message):
    sequence_id: int = betterproto.uint32_field(1)
    amount_minted: str = betterproto.string_field(2)
    remainder_to_mint: str = betterproto.string_field(3)
    last_mint_block_time: datetime = betterproto.message_field(4)
    remainder_from_previous_minter: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params defines the parameters for the module."""

    mint_denom: str = betterproto.string_field(1)
    start_time: datetime = betterproto.message_field(2)
    minters: List["Minter"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the cfeminter module's genesis state."""

    params: "Params" = betterproto.message_field(1)
    minter_state: "MinterState" = betterproto.message_field(2)
    """this line is used by starport scaffolding # genesis/proto/state"""

    state_history: List["MinterState"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    """QueryParamsRequest is request type for the Query/Params RPC method."""

    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is response type for the Query/Params RPC method.
    """

    params: "Params" = betterproto.message_field(1)
    """params holds all the parameters of this module."""


@dataclass(eq=False, repr=False)
class QueryInflationRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryInflationResponse(betterproto.Message):
    inflation: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryStateRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryStateResponse(betterproto.Message):
    minter_state: "MinterState" = betterproto.message_field(1)
    state_history: List["MinterState"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class MsgUpdateParams(betterproto.Message):
    authority: str = betterproto.string_field(1)
    mint_denom: str = betterproto.string_field(2)
    start_time: datetime = betterproto.message_field(3)
    minters: List["Minter"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class MsgUpdateParamsResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgUpdateMintersParams(betterproto.Message):
    authority: str = betterproto.string_field(1)
    start_time: datetime = betterproto.message_field(2)
    minters: List["Minter"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class MsgUpdateMintersParamsResponse(betterproto.Message):
    pass


class QueryStub(betterproto.ServiceStub):
    async def params(
        self,
        query_params_request: "QueryParamsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryParamsResponse":
        return await self._unary_unary(
            "/chain4energy.c4echain.cfeminter.Query/Params",
            query_params_request,
            QueryParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def inflation(
        self,
        query_inflation_request: "QueryInflationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryInflationResponse":
        return await self._unary_unary(
            "/chain4energy.c4echain.cfeminter.Query/Inflation",
            query_inflation_request,
            QueryInflationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def state(
        self,
        query_state_request: "QueryStateRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryStateResponse":
        return await self._unary_unary(
            "/chain4energy.c4echain.cfeminter.Query/State",
            query_state_request,
            QueryStateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgStub(betterproto.ServiceStub):
    async def update_minters_params(
        self,
        msg_update_minters_params: "MsgUpdateMintersParams",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateMintersParamsResponse":
        return await self._unary_unary(
            "/chain4energy.c4echain.cfeminter.Msg/UpdateMintersParams",
            msg_update_minters_params,
            MsgUpdateMintersParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_params(
        self,
        msg_update_params: "MsgUpdateParams",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateParamsResponse":
        return await self._unary_unary(
            "/chain4energy.c4echain.cfeminter.Msg/UpdateParams",
            msg_update_params,
            MsgUpdateParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryBase(ServiceBase):
    async def params(
        self, query_params_request: "QueryParamsRequest"
    ) -> "QueryParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def inflation(
        self, query_inflation_request: "QueryInflationRequest"
    ) -> "QueryInflationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def state(
        self, query_state_request: "QueryStateRequest"
    ) -> "QueryStateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_params(
        self, stream: "grpclib.server.Stream[QueryParamsRequest, QueryParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.params(request)
        await stream.send_message(response)

    async def __rpc_inflation(
        self,
        stream: "grpclib.server.Stream[QueryInflationRequest, QueryInflationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.inflation(request)
        await stream.send_message(response)

    async def __rpc_state(
        self, stream: "grpclib.server.Stream[QueryStateRequest, QueryStateResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.state(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/chain4energy.c4echain.cfeminter.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
            "/chain4energy.c4echain.cfeminter.Query/Inflation": grpclib.const.Handler(
                self.__rpc_inflation,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryInflationRequest,
                QueryInflationResponse,
            ),
            "/chain4energy.c4echain.cfeminter.Query/State": grpclib.const.Handler(
                self.__rpc_state,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryStateRequest,
                QueryStateResponse,
            ),
        }


class MsgBase(ServiceBase):
    async def update_minters_params(
        self, msg_update_minters_params: "MsgUpdateMintersParams"
    ) -> "MsgUpdateMintersParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_params(
        self, msg_update_params: "MsgUpdateParams"
    ) -> "MsgUpdateParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_update_minters_params(
        self,
        stream: "grpclib.server.Stream[MsgUpdateMintersParams, MsgUpdateMintersParamsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_minters_params(request)
        await stream.send_message(response)

    async def __rpc_update_params(
        self, stream: "grpclib.server.Stream[MsgUpdateParams, MsgUpdateParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_params(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/chain4energy.c4echain.cfeminter.Msg/UpdateMintersParams": grpclib.const.Handler(
                self.__rpc_update_minters_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateMintersParams,
                MsgUpdateMintersParamsResponse,
            ),
            "/chain4energy.c4echain.cfeminter.Msg/UpdateParams": grpclib.const.Handler(
                self.__rpc_update_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateParams,
                MsgUpdateParamsResponse,
            ),
        }
